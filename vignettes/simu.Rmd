---
title: "simu"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{simu}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)

#https://pengsu517.github.io/robcovsel
```

# System settings
```{r setup}
#########system settings
#remotes::install_github("PengSU517/robcovsel")
library(robcovsel)
#remotes::install_github("PengSU517/shootings") !!!!!!!!!!!!!!
#This shootings package is not my original work. The functions in this package were forked from https://github.com/ineswilms/sparse-shooting-S. I constructed a package of those functions to make them more convenient to use.
# rm(list = ls()) # clean slate
# setwd(dirname(rstudioapi::getSourceEditorContext()$path))
```

```{r parallel computation settings}
library(doParallel)
registerDoParallel(cores=8)
getDoParWorkers()

# to prevent automatic parallel computation when doing linear algebra (OpenBLAS)
#library(inline)
#openblas.set.num.threads <- cfunction( signature(ipt="integer"),
#                                         body = 'openblas_set_num_threads(*ipt);',
#                                         otherdefs = c ('extern void penblas_set_num_threads(int);'),
#                                         libargs = c #('/usr/lib/x86_64-linux-gnu/openblas/libblas.so.3'),
#                                         language = "C",
#                                         convention = ".C")
#openblas.set.num.threads(1) 
```

# Data generation settings 

Consider the linear regression model 
$$
y_i = \mathbf{x}_i^\top \pmb{\beta} + \varepsilon_i, i = 1,\ldots, n,
$$
in our simulations, we set $n = 100$, $p = 20$, $\pmb\beta = (1,2,1,2,1, \pmb 0_{p-5}^\top )^\top$, $\mathbf{x}_i$ is sampled from $N(\pmb 0,\pmb\Sigma_{xx})$ and $\varepsilon_i$ is sampled from $N(0,0.5^2)$. The correlation structure among variables is given by $\Sigma _{ij} = \rho^{|i-j|}$ and we set $\rho = 0.5$. 

Contamination proportions are set as $ 2\%$, $5\%$ and $10\%$ for all predictors separately. Outlying cells of all variables are randomly generated from $0.5 N(\gamma, 1)+ 0.5N(-\gamma, 1)$. We vary $\gamma$ over the set $\{0,2,4,6,8,10\}$ to simulate outliers with different magnitudes. When we apply appropriate $\gamma$'s, those cells will be outlying cells but not not necessarily marginal outliers.

For Lasso, ALGR and ALRP, we use the $\mathrm{BIC}$ as defined in (\ref{bic}) to choose the regularization tuning parameter $\lambda$. For sLTS and sShootingS, their default selection criteria are used. To assess the performance of the considered methods, we {use} the true positive rate (TPR), the false positive rate (FPR) and the balanced F-score ($\mathrm{F_1}$ score) {defined by}
$$
\mathrm{F_1} = \frac{\mathrm{TP}}{\mathrm{TP} + \frac{1}{2} (\mathrm{FP}+\mathrm{FN})},
$$
where TP {denotes} the true positive number, FP the false postive number and FN the false negative number, respectively. We run $1,000$ simulations for each scenario and use the average TPR, FPR and $\mathrm{F_1}$ score to measure the performance of each method.

```{r}
###### data generation settings
{
  ms = 1:1000
  ps = 10 # ps = 200 in high dimensional settings
  es = c(0.02, 0.05, 0.1)
  gammas = seq(0, 10, 2)
}


##### methods
{
  lassof = function(x,y){covlasso(x,y,cor.method = "pearson",scale.method = "sd", ada = F)$betahat_opt}
  sparseShootingSf = function(x,y){shootings::sparseshooting(x,y)$coef[-1]}
  sltsf = function(x,y){fit = robustHD::sparseLTS(x,y);fit$coefficients[-1]}
  algrf = function(x,y){covlasso(x,y,cor.method = "gaussrank", ada = T)$betahat_opt}
  alrpf = function(x,y){covlasso(x, y, ada = T)$betahat_opt}
  
  mtds = list(Lasso = lassof, 
              sLTS = sltsf, 
              sShootingS = sparseShootingSf,
              ALGR = algrf,
              ALRP = alrpf
  )
}

#### measurements
{
  msef<-function(betahat, beta){mean(((betahat-beta))^2)}
  mse5f<-function(betahat, beta){mean(((betahat-beta)[1:5])^2)}
  tpf<-function(betahat, beta){sum((as.logical(betahat)==as.logical(beta))[1:5])}
  tnf<-function(betahat,beta){sum((as.logical(betahat)==as.logical(beta))[-(1:5)])}
}


```


```{r}
version = 0
{
  systemtime = system.time({
    result <- foreach(m = ms, 
                      .packages = c("robustHD","robcovsel", "shootings"))%:%
      foreach(p = ps)%:%
      foreach(e = es)%:%
      foreach(gamma = gammas)%dopar% {
        
        seed = which(gammas==gamma) + 10*which(es==e) + 100*which(ps==p) + 1000*which(ms==m) + version 
        set.seed(seed = seed)
        
        dataset = robcovsel::genevar(n = 100, p = p, e = e, r = 0.5, gamma = gamma)
        #dataset = genevar(e = 0.1, gamma = 3)
        x = dataset$x
        y = dataset$y
        #plot(x[,1:2])
        #if(seed==1111){y = c(y,1)}
        beta = dataset$beta
        
        rst = list(lasso = NULL, slts = NULL, sss = NULL, algr = NULL, alrp = NULL)
        for (mtd in 1:length(mtds)) {
          try({
            betahat = mtds[[mtd]](x,y)
            mse = msef(betahat, beta)
            mse5 = mse5f(betahat, beta)
            tp = tpf(betahat, beta)
            tn = tnf(betahat, beta)
            rst[[mtd]] = c(m = m, n = 100, p = p, e = e, gamma = gamma, mtd = names(mtds)[mtd], seed =seed,  
                           mse = mse, mse5 = mse5, tp = tp, fp = (p-5)-tn)
          }, TRUE
          )
          if(is.null(rst[[mtd]])){# this part is just used to debug
            rst[[mtd]]=rep(NA, 11)
            save(seed, mtd, dataset, file = paste(mtd, "testerrordata", seed, ".RData", sep = ""))
          }
        }
        rst
      }
  })
  
  
  
  #save(result, file = "result_simu_p200.RData")
}
```




```{r analysis}
########################## analysis

library(tidyverse)
library(gridExtra)
library(grid)


result1 = as.data.frame(t(as.data.frame(result)))
result1 = result1[complete.cases(result1),]

glimpse(result1)
result1 = result1 %>% mutate(tp = as.numeric(tp), fp = as.numeric(fp), gamma = as.numeric(gamma), p = as.numeric(p),
                           fn = 5-tp, tn = p-5-fp, f1 = tp/(tp + 0.5*(fp+fn)), f1 = tp/(tp+0.5*(fp+fn))#,
                           #mcc = ((tp*tn + fp*fn)/sqrt((tp+fp)*(tp+fn)*(tn+fp)*(tn+fn)))
                           )

summary = result1 %>% group_by(n,p,e,gamma,mtd) %>% summarise(
  TPR = mean(tp/5, na.rm = T),FPR = mean(fp/(p-5), na.rm = T), F1 = mean(f1))%>%ungroup()
summary = summary %>% mutate(Method = factor(mtd, levels = c("ALRP",  "ALGR", "sShootingS", "sLTS","Lasso")))
summary$e = factor(summary$e, labels = c("e = 2%","e = 5%","e = 10%"))
glimpse(summary)


p1 = ggplot(data = summary, aes(x = gamma,y = F1, color = Method ))+geom_line()+geom_point()+facet_wrap(~e) +
  scale_x_continuous(breaks=seq(0,12,2)) +
  labs(fill = "", x = expression(gamma*": magnitude of outlyingness"), y = expression(F[1]))+ 
  guides(fill = guide_legend(title = "Thresholds")) +
  theme_light() +
  theme(text= element_text(size=20))

p2 = ggplot(data = summary, aes(x = gamma,y = MCC, color = Method ))+geom_line()+geom_point()+facet_wrap(~e) +
  scale_x_continuous(breaks=seq(0,12,2)) +
  labs(fill = "", x = "")+ 
  guides(fill = guide_legend(title = "Thresholds")) +
  theme_light() +
  theme(text= element_text(size=20))

p3 = ggplot(data = summary, aes(x = gamma,y = TPR, color = Method ))+geom_line()+geom_point()+ facet_wrap(~e) +
  scale_x_continuous(breaks=seq(0,12,2)) +
  ylim(0,1) +
  labs(fill = "", x = "")+ 
  guides(fill = guide_legend(title = "Thresholds")) +
  theme_light() +
  theme(text= element_text(size=20))

p4 = ggplot(data = summary, aes(x = gamma,y = FPR, color = Method ))+geom_line()+geom_point()+ facet_wrap(~e) +
  scale_x_continuous(breaks=seq(0,12,2)) +
  ylim(0,1) +
  labs(fill = "", x = "")+ 
  guides(fill = guide_legend(title = "Thresholds")) +
  theme_light() +
  theme(text= element_text(size=20))


grid_arrange_shared_legend <- function(..., ncol = length(list(...)), nrow = 1, position = c("bottom", "right")) {
  
  plots <- list(...)
  position <- match.arg(position)
  g <- ggplotGrob(plots[[1]] + theme(legend.position = position))$grobs
  legend <- g[[which(sapply(g, function(x) x$name) == "guide-box")]]
  lheight <- sum(legend$height)
  lwidth <- sum(legend$width)
  gl <- lapply(plots, function(x) x + theme(legend.position="none"))
  gl <- c(gl, ncol = ncol, nrow = nrow)
  
  combined <- switch(position,
                     "bottom" = arrangeGrob(do.call(arrangeGrob, gl),
                                            legend,
                                            ncol = 1,
                                            heights = unit.c(unit(1, "npc") - lheight, lheight)),
                     "right" = arrangeGrob(do.call(arrangeGrob, gl),
                                           legend,
                                           ncol = 2,
                                           widths = unit.c(unit(1, "npc") - lwidth, lwidth)))
  
  grid.newpage()
  grid.draw(combined)
  # return gtable invisibly
  invisible(combined)
  
}


pp = grid_arrange_shared_legend(p3,p4,p1, nrow = 3, ncol = 1, position = "bottom")
#ggsave("plots_200.eps", plot = pp, width = 10,height = 8)
```

```{r, fig.width=10, fig.height=10}
pp
```




   
   

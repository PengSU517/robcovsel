---
title: "Simulation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{simu}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)

#https://pengsu517.github.io/robcovsel
```

# System settings
```{r setup}
#########system settings
#remotes::install_github("PengSU517/robcovsel")
#remotes::install_github("PengSU517/shootings") !!!!!!!!!!!!!!
#this shootings package is constructed based on ineswilms/sparse-shooting-S
#rm(list = ls()) # clean slate
#setwd(dirname(rstudioapi::getSourceEditorContext()$path))

#This shootings package is not my original work. The functions in this package were forked from https://github.com/ineswilms/sparse-shooting-S. I constructed a package of those functions to make them more convenient to use.
# rm(list = ls()) # clean slate
# setwd(dirname(rstudioapi::getSourceEditorContext()$path))
```

```{r parallel computation settings}
#library(doParallel)
#registerDoParallel(cores=8)
#getDoParWorkers()

# to prevent automatic parallel computation when doing linear algebra (OpenBLAS)
#library(inline)
#openblas.set.num.threads <- cfunction( signature(ipt="integer"),
#                                         body = 'openblas_set_num_threads(*ipt);',
#                                         otherdefs = c ('extern void penblas_set_num_threads(int);'),
#                                         libargs = c #('/usr/lib/x86_64-linux-gnu/openblas/libblas.so.3'),
#                                         language = "C",
#                                         convention = ".C")
#openblas.set.num.threads(1) 
```

# Data generation settings 

Consider the linear regression model 
$$
y_i = \mathbf{x}_i^\top \pmb{\beta} + \varepsilon_i, i = 1,\ldots, n,
$$
in our simulations, we set $n = 100$, $p = 20$, $\pmb\beta = (1,2,1,2,1, \pmb 0_{p-5}^\top )^\top$, $\mathbf{x}_i$ is sampled from $N(\pmb 0,\pmb\Sigma_{xx})$ and $\varepsilon_i$ is sampled from $N(0,0.5^2)$. The correlation structure among variables is given by $\Sigma _{ij} = \rho^{|i-j|}$ and we set $\rho = 0.5$. 

Contamination proportions are set as $ 2\%$, $5\%$ and $10\%$ for all predictors separately. Outlying cells of all variables are randomly generated from $0.5 N(\gamma, 1)+ 0.5N(-\gamma, 1)$. We vary $\gamma$ over the set $\{0,2,4,6,8,10\}$ to simulate outliers with different magnitudes. When we apply appropriate $\gamma$'s, those cells will be outlying cells but not not necessarily marginal outliers.

For Lasso, ALGR and ALRP, we use the $\mathrm{BIC}$ as defined in (\ref{bic}) to choose the regularization tuning parameter $\lambda$. For sLTS and sShootingS, their default selection criteria are used. To assess the performance of the considered methods, we {use} the true positive rate (TPR), the false positive rate (FPR) and the balanced F-score ($\mathrm{F_1}$ score) {defined by}
$$
\mathrm{F_1} = \frac{\mathrm{TP}}{\mathrm{TP} + \frac{1}{2} (\mathrm{FP}+\mathrm{FN})},
$$
where TP {denotes} the true positive number, FP the false postive number and FN the false negative number, respectively. We run $1,000$ simulations for each scenario and use the average TPR, FPR and $\mathrm{F_1}$ score to measure the performance of each method.


# Visualization
```{r analysis}

library(tidyverse)
library(gridExtra)
library(grid)
library(robcovsel)
load("result_simu_p200.RData")

result1 = as.data.frame(t(as.data.frame(result)))
result1 = result1[complete.cases(result1),]
result1 = result1 %>% mutate(tp = as.numeric(tp), fp = as.numeric(fp), gamma = as.numeric(gamma), p = as.numeric(p), fn = 5-tp, tn = p-5-fp, f1 = tp/(tp + 0.5*(fp+fn)), f1 = tp/(tp+0.5*(fp+fn)))
#mcc = ((tp*tn + fp*fn)/sqrt((tp+fp)*(tp+fn)*(tn+fp)*(tn+fn)))

summary = result1 %>% group_by(n,p,e,r,gamma,mtd) %>% summarise(
  TPR = mean(tp/5, na.rm = T),FPR = mean(fp/(p-5), na.rm = T), F1 = mean(f1))%>%ungroup()
summary = summary %>% mutate(Method = factor(mtd, levels = c("ALRP",  "ALGR", "LRP",  "LGR", "sShootingS", "sLTS", "aLasso", "Lasso")))
summary$e = factor(summary$e, labels = c("e = 2%","e = 5%","e = 10%"))
summary$r = factor(summary$r, labels = c("r = 0.5","r = 0.7","r = 0.9"))
summary1 = summary %>% filter(r == "r = 0.9")

```


```{r}
p1 = ggplot(data = summary1, aes(x = gamma,y = F1, color = Method ))+
  geom_line()+geom_point()+facet_grid(.~e) +
  scale_x_continuous(breaks=seq(0,12,2)) +
  labs(fill = "", x = expression(gamma*": magnitude of outlyingness"), y = expression(F[1]))+ 
  guides(fill = guide_legend(title = "Thresholds")) +
  theme_light() +
  theme(text= element_text(size=20), legend.position = "bottom")

p2 = ggplot(data = summary1, aes(x = gamma,y = TPR, color = Method ))+
  geom_line()+geom_point()+facet_grid(.~e) +
  scale_x_continuous(breaks=seq(0,12,2)) +
  ylim(0,1) +
  labs(fill = "", x = "")+ 
  guides(fill = guide_legend(title = "Thresholds")) +
  theme_light() +
  theme(text= element_text(size=20), legend.position = "bottom")

p3 = ggplot(data = summary1, aes(x = gamma,y = FPR, color = Method ))+
  geom_line()+geom_point()+facet_grid(.~e) +
  scale_x_continuous(breaks=seq(0,12,2)) +
  ylim(0,1) +
  labs(fill = "", x = "")+ 
  guides(fill = guide_legend(title = "Thresholds")) +
  theme_light() +
  theme(text= element_text(size=20), legend.position = "bottom")

```


```{r  fig.width=10, fig.height=10}
p1

p2

p3

ggsave("plots_20_f1.eps", plot = p1, width = 10,height = 8)

ggsave("plots_20_tpr.eps", plot = p2, width = 10,height = 8)

ggsave("plots_20_fpr.eps", plot = p3, width = 10,height = 8)
```











```{r fig.width=10, fig.height=10}
grid_arrange_shared_legend <- function(..., ncol = length(list(...)), nrow = 1, position = c("bottom", "right")) {
  
  plots <- list(...)
  position <- match.arg(position)
  g <- ggplotGrob(plots[[1]] + theme(legend.position = position))$grobs
  legend <- g[[which(sapply(g, function(x) x$name) == "guide-box")]]
  lheight <- sum(legend$height)
  lwidth <- sum(legend$width)
  gl <- lapply(plots, function(x) x + theme(legend.position="none"))
  gl <- c(gl, ncol = ncol, nrow = nrow)
  
  combined <- switch(position,
                     "bottom" = arrangeGrob(do.call(arrangeGrob, gl),
                                            legend,
                                            ncol = 1,
                                            heights = unit.c(unit(1, "npc") - lheight, lheight)),
                     "right" = arrangeGrob(do.call(arrangeGrob, gl),
                                           legend,
                                           ncol = 2,
                                           widths = unit.c(unit(1, "npc") - lwidth, lwidth)))
  
  grid.newpage()
  grid.draw(combined)
  # return gtable invisibly
  invisible(combined)
  
}


pp = grid_arrange_shared_legend(p1,p2,p3, nrow = 3, ncol = 1, position = "bottom")
ggsave("plots_200_r09.eps", plot = pp, width = 10,height = 10)
```
























   
   
